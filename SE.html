<!DOCTYPE html>

<html lang="en-US">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Online Job Portal System Documentation</title>
<script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
<style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 800px;
            margin: 0px auto;
            padding: 24px 40px;
            background-color: #fff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #1a237e;
            margin-top: 1.5em;
            margin-bottom: 0.8em;
            font-weight: 600;
        }
        h1 {
            font-size: 2.2em;
            text-align: center;
            margin-bottom: 1em;
        }
        h2 {
            font-size: 1.8em;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 0.3em;
        }
        h3 {
            font-size: 1.4em;
        }
        p {
            margin-bottom: 1em;
        }
        a {
            color: #1a73e8;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        strong {
            color: #c62828;
        }
        code {
            background-color: #f0f2f5;
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 3px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
        }
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 1em;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: inherit;
            color: inherit;
        }
        ul, ol {
            padding-left: 20px;
        }
        li {
            margin-bottom: 0.5em;
        }
        .table-container {
            overflow-x: auto;
            margin: 1.5em 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            font-family: inherit;
        }
        th {
            background-color: #f2f2f2;
            font-weight: 600;
        }
        #toc {
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px 25px;
            margin-bottom: 2em;
        }
        #toc h2 {
            font-size: 1.5em;
            border-bottom: none;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        #toc ul {
            padding-left: 20px;
            margin: 0;
        }
        #toc ul ul {
            padding-left: 25px;
        }
        #toc li {
            margin-bottom: 0.5em;
        }
        .chart-wrapper {
            width: 100%;
            height: 450px;
            margin: 20px 0;
        }
        .data-source {
            text-align: center;
            font-size: 0.9em;
            color: #666;
            margin-top: -15px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
<div class="container">
<h1 id="online-job-portal-system-documentation">Online Job Portal System Documentation</h1>
<div id="toc">
<h2>Table of Contents</h2>
<ul>
<li><a href="#chapter-1-introduction">Chapter 1: Introduction</a>
<ul>
<li><a href="#11-background">1.1 Background</a></li>
<li><a href="#12-statement-of-the-problem">1.2 Statement of the Problem</a></li>
<li><a href="#13-objectives">1.3 Objectives</a></li>
<li><a href="#14-scope">1.4 Scope</a></li>
<li><a href="#15-methodology">1.5 Methodology</a></li>
<li><a href="#16-feasibility-study">1.6 Feasibility Study</a></li>
</ul>
</li>
<li><a href="#chapter-2-requirement-elicitation">Chapter 2: Requirement Elicitation</a>
<ul>
<li><a href="#21-overview">2.1 Overview</a></li>
<li><a href="#22-current-system-and-business-process">2.2 Current System and Business Process</a></li>
<li><a href="#23-proposed-system">2.3 Proposed System</a></li>
<li><a href="#24-functional-requirements">2.4 Functional Requirements</a></li>
<li><a href="#25-non-functional-requirements">2.5 Non-Functional Requirements</a></li>
</ul>
</li>
<li><a href="#chapter-3-system-analysis">Chapter 3: System Analysis</a>
<ul>
<li><a href="#31-overview">3.1 Overview</a></li>
<li><a href="#32-use-case-diagram">3.2 Use Case Diagram</a></li>
<li><a href="#33-class-diagram">3.3 Class Diagram</a></li>
<li><a href="#34-sequence-diagram">3.4 Sequence Diagram</a></li>
<li><a href="#35-activity-diagram">3.5 Activity Diagram</a></li>
</ul>
</li>
<li><a href="#chapter-4-system-design">Chapter 4: System Design</a>
<ul>
<li><a href="#41-overview">4.1 Overview</a></li>
<li><a href="#42-system-architecture">4.2 System Architecture</a></li>
<li><a href="#43-deployment-diagram">4.3 Deployment Diagram</a></li>
<li><a href="#44-component-diagram">4.4 Component Diagram</a></li>
<li><a href="#45-persistent-data-model">4.5 Persistent Data Model</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="chapter-1-introduction">Chapter 1: Introduction</h2>
<h3 id="11-background">1.1 Background</h3>
<p>Online job portals have become a cornerstone of modern recruitment, connecting job seekers with employers efficiently over the internet. These platforms allow job seekers to create profiles, upload resumes, and search for jobs, while employers can post vacancies and search candidate profiles. The global online recruitment market has grown significantly, valued at approximately $33.1 billion in 2023 and projected to reach $61.4 billion by 2032 (<a href="https://www.skyquestt.com/report/online-recruitment-market" target="_blank">[skyquestt.com]</a>). In the United States alone, online recruitment sites generate over $14 billion in annual revenue (<a href="https://www.ibisworld.com/united-states/industry/online-recruitment-sites/4590/" target="_blank">[ibisworld.com]</a>). This growth is driven by the convenience and reach of web-based hiring, especially as more people turn to the internet for job searching and companies increasingly rely on digital channels to find talent.</p>
<p>Traditional recruitment methods, such as newspaper ads or in-person job fairs, are being eclipsed by online portals due to their broader reach and cost-effectiveness. For example, online job boards significantly reduce the cost per hire compared to traditional methods (<a href="https://www.ijcrt.org/papers/IJCRT2504429.pdf" target="_blank">[ijcrt.org]</a>). Major job portals like Indeed, LinkedIn Jobs, and Glassdoor have millions of users and postings, demonstrating the scale of this trend. In recent years, even specialized niche portals have emerged for specific industries or job types, catering to diverse user needs. The COVID-19 pandemic further accelerated the shift to online hiring, as remote work and virtual recruitment became the norm. Overall, online job portals have transformed the employment landscape by making the job search and hiring process faster, more accessible, and more data-driven.</p>
<h3 id="12-statement-of-the-problem">1.2 Statement of the Problem</h3>
<p>Despite the prevalence of online job portals, there are several challenges and pain points in the current system that this project aims to address. Many existing platforms suffer from usability issues – for instance, studies have found that some job search websites have unintuitive interfaces and features that confuse users (<a href="https://www.ajqr.org/download/demystifying-the-user-experience-a-case-study-on-online-job-search-engines-11411.pdf" target="_blank">[ajqr.org]</a>). Novice job seekers may struggle with complex navigation or unclear application processes, leading to frustration and lost opportunities. Additionally, job seekers often complain about irrelevant job recommendations and spammy job alerts, while employers face issues like receiving an overwhelming number of unqualified applications (<a href="https://iarjset.com/wp-content/uploads/2025/07/IARJSET.2025.12705.pdf" target="_blank">[iarjset.com]</a>). A 2024 survey highlights these issues, with a significant majority of employers citing problems such as an influx of unqualified applicants, candidate ghosting, and high costs associated with using job boards.</p>
<div class="chart-wrapper" id="chart2"></div>
<div class="data-source">Data Source: <a href="https://www.ihire.com/resourcecenter/employer/pages/the-state-of-online-recruiting-2024" target="_blank">[iHire 2024]</a></div>
<p>Another problem is the fragmentation of information: job seekers often have to use multiple sites or repeatedly fill out forms, and employers may use separate tools for postings, screening, and communication. This inefficiency can prolong the hiring cycle and reduce the quality of matches. There is also a need for better personalization and matching algorithms – static keyword-based matching can miss good candidates or jobs that don’t fit obvious criteria. Furthermore, the system must ensure security and privacy, as it handles sensitive personal and employment data. In summary, the current job portal landscape can be improved by a more user-friendly, efficient, and intelligent system that truly bridges the gap between job seekers and employers.</p>
<h3 id="13-objectives">1.3 Objectives</h3>
<p>The primary objective of this Online Job Portal System project is to design and implement a comprehensive web-based platform that effectively connects job seekers with employers. The system will provide a user-friendly interface and robust functionality to streamline the recruitment process. Key objectives include:</p>
<ul>
<li><strong>Centralize Job Search and Hiring:</strong> Create a single platform where job seekers can find relevant job opportunities and employers can post vacancies and find suitable candidates, eliminating the need for multiple disjointed tools.</li>
<li><strong>Improve Usability and User Experience:</strong> Design an intuitive interface that is easy for all types of users (novice job seekers, experienced professionals, recruiters, etc.) to navigate (<a href="https://www.ajqr.org/download/demystifying-the-user-experience-a-case-study-on-online-job-search-engines-11411.pdf" target="_blank">[ajqr.org]</a>). This includes clear workflows for registration, profile creation, job posting, and application submission.</li>
<li><strong>Enhance Matching and Relevance:</strong> Implement intelligent matching algorithms to recommend jobs to seekers and candidate profiles to employers based on skills, experience, and preferences, thereby reducing mismatches and improving the quality of matches (<a href="https://iarjset.com/wp-content/uploads/2025/07/IARJSET.2025.12705.pdf" target="_blank">[iarjset.com]</a>).</li>
<li><strong>Streamline Communication:</strong> Provide built-in communication channels (such as messaging or email integration) so that employers and applicants can interact directly through the portal, improving response times and reducing “ghosting” issues.</li>
<li><strong>Ensure Security and Privacy:</strong> Protect user data with secure authentication, authorization, and data encryption. The system will comply with privacy standards to safeguard personal and professional information of users.</li>
<li><strong>Support Scalability and Reliability:</strong> Design the system architecture to handle a growing number of users and postings without performance degradation, ensuring the platform remains available and fast even under high load.</li>
<li><strong>Offer Flexibility and Extensibility:</strong> Build the system in a modular way so that new features (such as analytics, mobile app integration, or additional user roles) can be added in the future with minimal disruption.</li>
</ul>
<p>By achieving these objectives, the Online Job Portal System aims to create a more efficient and satisfactory experience for both job seekers and employers, ultimately increasing the likelihood of successful job placements.</p>
<h3 id="14-scope">1.4 Scope</h3>
<p>The scope of this project encompasses the development of a web-based Online Job Portal System with core functionalities for job seekers, employers, and an administrator. The system will be implemented as a web application accessible via standard web browsers. Key in-scope elements include:</p>
<ul>
<li><strong>User Roles:</strong> The system caters to three main user roles – <strong>Job Seeker</strong>, <strong>Employer</strong>, and <strong>Administrator</strong>. Each role has distinct features and permissions within the system (<a href="https://www.ijsat.org/research-paper.php?id=6188" target="_blank">[ijsat.org]</a>).</li>
<li><strong>Job Seeker Features:</strong> Registration and profile creation, uploading resumes, searching and browsing job listings, applying to jobs, saving favorite jobs, and receiving job alerts.</li>
<li><strong>Employer Features:</strong> Registration and company profile creation, posting and managing job openings, searching and viewing candidate profiles, sending messages to applicants, and viewing application statuses.</li>
<li><strong>Administrator Features:</strong> Managing user accounts (approving/blocking users), moderating job postings and resumes (to ensure they comply with guidelines), handling reports of inappropriate content, and system configuration.</li>
<li><strong>Core Workflows:</strong> The system covers the end-to-end workflows of job posting, job searching, application submission, and communication. For example, an employer can post a job, which job seekers can then find and apply to; the employer can review applications and contact selected candidates, all within the portal.</li>
<li><strong>Platform and Technology:</strong> The project focuses on a web-based solution. While a mobile-responsive design is intended for accessibility on various devices, a native mobile app is not included in the initial scope. The system will be developed using modern web technologies (detailed in later chapters) and will be deployed on a cloud server for demonstration purposes.</li>
</ul>
<p>Out-of-scope elements for this project include advanced AI features beyond basic matching (such as automated resume screening using machine learning, which could be an enhancement in future work), payment processing for premium services (the system is free to use in this scope), and integration with third-party job boards or social media login (which are considered extensions). The scope is bounded to ensure the project remains manageable and achievable within the given constraints, delivering a functional core system that can be expanded later.</p>
<h3 id="15-methodology">1.5 Methodology</h3>
<p>The development of the Online Job Portal System will follow a structured software engineering methodology to ensure a systematic and efficient process. We will adopt an <strong>Agile development approach</strong> combined with elements of <strong>Object-Oriented Analysis and Design (OOAD)</strong>. Agile methodologies, such as Scrum, emphasize iterative development, collaboration, and responsiveness to change (<a href="https://www.atlassian.com/agile/project-management/user-stories" target="_blank">[atlassian.com]</a>). This is well-suited for our project because requirements in the software industry can evolve, and we want to deliver working increments of the system at regular intervals. We will break the project into short development sprints (typically 2-4 weeks each), during which we plan, design, implement, and test a set of features. At the end of each sprint, we will review the progress with stakeholders and incorporate feedback, ensuring the product aligns with user needs.</p>
<p>Within each iteration, we will use <strong>OOAD principles</strong> for analysis and design. OOAD involves understanding the problem domain, identifying key entities (objects), and designing their interactions (<a href="https://www.geeksforgeeks.org/software-engineering/object-oriented-analysis-and-design/" target="_blank">[geeksforgeeks.org]</a>). We will start by defining use cases and user stories to capture functional requirements from the user’s perspective (<a href="https://www.parabol.co/blog/user-story-examples/" target="_blank">[parabol.co]</a>). For example, a user story might be: “As a job seeker, I want to search for jobs by location and keyword so that I can find relevant opportunities.” These user stories will guide our design of classes and interactions. We will create UML diagrams (use case diagrams, class diagrams, sequence diagrams, etc.) to model the system’s structure and behavior, which helps in visualizing how different components will work together (<a href="https://medium.com/analysts-corner/object-oriented-analysis-3-diagrams-you-must-master-ddaae59abcf9" target="_blank">[medium.com]</a>).</p>
<p>Throughout development, we will employ <strong>iterative prototyping and testing</strong>. After each iteration, a prototype of the system with new features will be tested internally. We will use both manual testing and automated unit/integration tests to ensure quality. Any issues or new requirements identified will be fed back into the backlog for subsequent sprints. This iterative testing and feedback loop is a hallmark of Agile and will help in early detection of problems and continuous improvement of the system.</p>
<p>Additionally, we will follow <strong>Agile best practices</strong> such as daily stand-up meetings to coordinate the team, sprint planning and review sessions, and maintaining a prioritized product backlog. Version control (using Git) and collaborative development tools will be used to manage code changes and ensure team coordination. By combining Agile’s flexibility with OOAD’s structured design approach, we aim to develop the Online Job Portal System in an efficient, transparent, and quality-focused manner.</p>
<h3 id="16-feasibility-study">1.6 Feasibility Study</h3>
<p>Before proceeding with full-scale development, a feasibility study was conducted to assess the viability of the Online Job Portal System project. The study evaluated the project from several angles – technical, economic, operational, and schedule feasibility – to ensure that the proposed system is both practical and beneficial. Key findings of the feasibility study are summarized below:</p>
<ul>
<li><strong>Technical Feasibility:</strong> The project is technically feasible with current technologies. The required functionalities (user authentication, database management, web development, etc.) are well-understood and achievable with modern tools. We plan to use a robust tech stack (e.g., a popular web framework for the backend and a responsive frontend framework) which are widely supported and have large developer communities. The system’s design will be modular, which will help in managing complexity. Potential technical risks (such as handling high concurrency or ensuring data security) can be mitigated with proven solutions (e.g., using cloud hosting for scalability and implementing security best practices). Overall, the team possesses or can acquire the necessary technical skills to develop and deploy the system successfully.</li>
<li><strong>Economic Feasibility:</strong> The project is economically feasible in terms of cost-benefit. The development costs (software licenses, cloud hosting, developer time) are estimated and within the allocated budget. Since the initial scope does not include monetization features, the immediate economic benefit is not direct revenue but the value provided to users. However, a successful job portal can attract a large user base, which in the future could be monetized (through job posting fees, premium accounts, etc.), potentially yielding a positive return on investment. Even in the short term, the system will reduce manual effort in recruitment (for both job seekers and employers) and thus has intangible economic benefits. The cost of not implementing the system (continuing with inefficient manual or fragmented processes) is considered higher in the long run. Therefore, the project is deemed financially justifiable.</li>
<li><strong>Operational Feasibility:</strong> The system is operationally feasible, meaning it fits into the intended operating environment and will be accepted by users. Job seekers and employers are already accustomed to using online job portals, so there is a clear need and willingness to use such a system. The interface will be designed to be user-friendly, minimizing the learning curve for new users. The system will also comply with relevant laws and regulations (such as data protection laws) to ensure it can be operated legally and ethically. We anticipate that once deployed, the system will be maintained by a small team for updates and support, which is operationally manageable. Stakeholder feedback gathered during requirements elicitation indicates strong support for the project, suggesting that the system will be used effectively once implemented.</li>
<li><strong>Schedule Feasibility:</strong> The project timeline is realistic and achievable. We have broken down the work into phases and sprints (as per the chosen Agile methodology) with clear deliverables for each. The estimated development period is aligned with the project’s resource availability and deadlines. The use of an iterative approach means that even if some tasks take longer than planned, we can adjust scope in subsequent sprints to meet the overall timeline. Contingency time has been allocated for unexpected delays or complexities. Based on the project plan, the core system can be developed and deployed within the expected timeframe, making the schedule feasible.</li>
</ul>
<p>In conclusion, the feasibility study indicates that the Online Job Portal System project is viable on all fronts. There are no major showstoppers identified; instead, the study confirms that the project aligns with technical capabilities, offers economic and operational benefits, and can be delivered within the planned schedule. This positive outcome provides a green light to proceed with the detailed requirement elicitation and system design phases.</p>
<h2 id="chapter-2-requirement-elicitation">Chapter 2: Requirement Elicitation</h2>
<h3 id="21-overview">2.1 Overview</h3>
<p>Requirement elicitation is the process of gathering and understanding the requirements for the system from various stakeholders. In this chapter, we describe how we identified and documented the requirements for the Online Job Portal System. The goal of requirement elicitation is to capture all the necessary functionalities and constraints that the system must satisfy, based on the needs of job seekers, employers, and administrators. We employed multiple techniques – including interviews, surveys, and analysis of existing systems – to ensure we have a comprehensive and accurate set of requirements. By involving potential users and analyzing current job portal practices, we aim to define a system that truly addresses the users’ needs and expectations.</p>
<p>During the elicitation process, we interacted with several stakeholders. For job seekers, we interviewed individuals with varying levels of experience (from fresh graduates to experienced professionals) to understand their job search habits and pain points. For employers, we spoke with HR personnel and recruiters to learn about their hiring processes and challenges in finding candidates. We also reviewed feedback from existing online job portals (such as user reviews and forums) to identify common complaints and desired features. In addition, we examined the features of popular job portals (Indeed, LinkedIn Jobs, Glassdoor, etc.) to benchmark against industry standards. This multi-faceted approach helped us gather both qualitative insights (like user preferences and frustrations) and quantitative data (like the typical number of applications per job or average time to hire) that informed our requirements.</p>
<p>All elicited requirements were documented in a clear and structured manner. We categorized requirements into <strong>functional requirements</strong> (what the system should do) and <strong>non-functional requirements</strong> (how the system should perform). Functional requirements are described in terms of user stories and use cases, capturing the actions users will perform and the system’s responses. Non-functional requirements, such as performance, security, and usability criteria, were noted to ensure the system meets quality expectations. The requirement elicitation phase also involved validation – we presented the gathered requirements to stakeholders for review and clarification, ensuring that there were no misunderstandings and that all critical needs were captured. With the requirements defined, we can now proceed to analyze and design the system in subsequent chapters.</p>
<h3 id="22-current-system-and-business-process">2.2 Current System and Business Process</h3>
<p>Before designing the new Online Job Portal System, it is important to understand the current state of the process it will replace or enhance. In many cases, the “current system” for job seekers and employers is a combination of manual and semi-digital processes, often involving multiple platforms. Here we outline the typical current business process for job posting and searching, and identify its limitations:</p>
<ul>
<li><strong>Job Posting by Employers:</strong> Currently, an employer (or recruiter) looking to fill a position might post the job on multiple channels. They may use a company careers page, general job boards (like Indeed), niche job sites, or even social media. Each platform may have its own interface and requirements for posting a job. The employer often has to manually enter job details (title, description, requirements, etc.) on each site. There is usually no centralized system, so tracking responses can be cumbersome. Some employers use internal Applicant Tracking Systems (ATS) to manage hiring, but posting to external boards is a separate step. The current process can be time-consuming and error-prone (e.g., a job might be posted on one site but forgotten on another, leading to inconsistent information).</li>
<li><strong>Job Search by Seekers:</strong> A job seeker typically searches for jobs by visiting various job boards or company websites. They might create accounts on multiple portals and upload their resume each time. Searching for jobs involves manually entering keywords and filters on each site, which can yield redundant results across platforms. The seeker then applies to jobs by either using an online application form on the job board or by emailing their resume if that’s the method provided. Keeping track of all applications and their statuses is often done by the job seeker manually (for example, maintaining a spreadsheet of where they applied and when). Communication with employers is usually via email or phone outside of the job board platform. This fragmented approach means job seekers may miss opportunities or spend a lot of time on repetitive tasks.</li>
<li><strong>Communication and Selection:</strong> Once a job seeker applies, the employer reviews applications (often spread across emails or different ATS inboxes). If interested, the employer contacts the candidate via email or phone to schedule an interview. There is typically no integrated communication within the job board beyond the initial application. This lack of a centralized communication channel can lead to delays and lost messages. It’s also common for candidates to not hear back from employers (ghosting), which is a known issue in the current process. The absence of feedback loops and status updates in the current system leaves candidates uncertain about the progress of their applications.</li>
<li><strong>Administrative Oversight:</strong> In the current scenario, each job board has its own administrators who handle user support, content moderation, and technical maintenance. For a new portal, this would initially be a manual process – administrators might review new user accounts or job postings to ensure they meet guidelines, but on larger platforms this is often automated or not thoroughly done, leading to issues like spam postings or fake profiles. Without a dedicated system, administrative tasks can become bottlenecks (for example, manually verifying each new employer account could slow down onboarding).</li>
</ul>
<p>The limitations of the current system are evident: <strong>inefficiency</strong> (duplicate efforts, lack of integration), <strong>poor user experience</strong> (cumbersome application processes, difficulty in tracking applications), <strong>communication gaps</strong> (no real-time interaction), and <strong>inconsistent data</strong> (job postings may differ across sites, resumes are scattered). These shortcomings underscore the need for a more unified and automated system. The proposed Online Job Portal System aims to streamline these processes by consolidating them into one platform, thereby eliminating many of the current inefficiencies.</p>
<h3 id="23-proposed-system">2.3 Proposed System</h3>
<p>The proposed Online Job Portal System is designed to overcome the limitations of the current process by providing an integrated, user-friendly platform for job seekers and employers. In this system, all major activities – from job posting to application to communication – will be handled within one unified environment. Below is an overview of how the proposed system will function and the improvements it will bring:</p>
<ul>
<li><strong>Unified Platform:</strong> Both job seekers and employers will use a single web portal. Job seekers create one profile and can apply to multiple jobs through that profile, eliminating the need to re-enter information on different sites. Employers create company profiles and can post all their job openings in one place, accessible to all registered job seekers. This centralization ensures that all relevant information is in one database, making it easier to search and manage.</li>
<li><strong>User Registration and Profiles:</strong> The system will have a secure registration process for both job seekers and employers. Upon registration, job seekers build a profile that includes their personal information, education, work experience, skills, and upload their resume. Employers create a company profile with details about the organization. These profiles will be searchable (with appropriate permissions): employers can search candidate profiles, and job seekers can view company profiles. Having profiles means users only need to input their information once, and the system can use this data to personalize their experience.</li>
<li><strong>Job Posting and Management:</strong> Employers will be able to post job openings through a guided form. The form will prompt for necessary details (job title, description, requirements, location, salary range, etc.). The system will allow employers to manage their postings – for example, edit or delete a job, mark it as filled, or renew it. Unlike the current process of posting on multiple sites, in the proposed system a single post reaches all potential candidates on the platform. The system can also automatically notify interested job seekers (via email or in-app alerts) when a new job matching their criteria is posted, increasing visibility of the job.</li>
<li><strong>Job Search and Application:</strong> Job seekers will have a powerful search interface to find jobs. They can search by keyword, location, job type, industry, etc., and filter results (for example, only show full-time jobs in New York). The system’s search will leverage the data in job postings and candidate profiles to provide relevant matches. When a job seeker finds a suitable job, they can apply with one click using their stored resume and profile. The application is then sent directly to the employer through the system. The proposed system keeps a record of all applications a seeker has submitted, so they can track the status (e.g., “Applied”, “Under Review”, “Interview Scheduled”, “Rejected”) within their dashboard. This addresses the current problem of not knowing what happened to an application.</li>
<li><strong>Communication and Collaboration:</strong> A key feature of the proposed system is an integrated communication module. Employers and job seekers can send messages to each other through the portal (for example, an employer can message a candidate to schedule an interview, or a candidate can ask a question about the job). Notifications will alert users of new messages. This ensures all communication is logged within the system, reducing the chance of messages getting lost and providing a convenient history of interactions. Additionally, the system can facilitate scheduling (e.g., suggesting interview slots) and allow employers to give feedback to candidates after the hiring process, improving transparency.</li>
<li><strong>Administrator Control:</strong> The system will include an administrator module to oversee the platform. The admin can review new user registrations (especially for employers, to prevent fraudulent accounts), monitor job postings for any violations of terms (such as inappropriate content), and handle user reports. The admin can also generate reports on system usage (number of jobs posted, number of applications, etc.). This active moderation will help maintain a safe and trustworthy environment, which is an improvement over current systems where spam or fake listings can sometimes go unchecked.</li>
<li><strong>Security and Privacy:</strong> The proposed system will enforce security measures such as encryption of sensitive data (like passwords and personal information), role-based access control (so users can only access their own data or the data they are authorized to see), and compliance with privacy regulations. For example, job seekers will have control over their profile visibility (they might choose to make their profile visible to employers or keep it private if they are currently employed). The system will also have backup and disaster recovery plans to ensure data is not lost and the service remains available.</li>
</ul>
<p>Overall, the proposed Online Job Portal System will create a <strong>closed-loop ecosystem</strong> for recruitment. Job seekers and employers interact through the system from start to finish, which should significantly improve efficiency and user satisfaction. By learning from the shortcomings of existing solutions and leveraging modern technology, the new system aims to set a higher standard for online job portals in terms of usability, effectiveness, and reliability.</p>
<h3 id="24-functional-requirements">2.4 Functional Requirements</h3>
<p>Functional requirements define the specific functionalities and features that the Online Job Portal System must provide. These requirements are described from the perspective of the users and the tasks they need to accomplish. We have categorized the functional requirements by user role – Job Seeker, Employer, and Administrator – to ensure clarity on who can perform each function. Below is a list of the key functional requirements for the system:</p>
<ul>
<li><strong>User Authentication and Authorization:</strong>
<ul>
<li>The system shall allow new users to register with a unique username/email and password. Registration will have separate flows for job seekers and employers (capturing different profile information).</li>
<li>The system shall support user login and logout. Upon successful login, the system will redirect users to their respective dashboards (job seeker dashboard or employer dashboard) based on their role.</li>
<li>Passwords shall be securely stored (hashed) and the system shall provide a password reset functionality for users who forget their password.</li>
<li>Each user account will have a defined role (Job Seeker, Employer, or Administrator). The system will enforce role-based authorization, meaning each user can only access the features and data appropriate to their role (e.g., employers cannot apply to jobs, job seekers cannot post jobs, etc.).</li>
</ul>
</li>
<li><strong>Job Seeker Functions:</strong>
<ul>
<li><strong>Profile Management:</strong> A job seeker shall be able to create and edit a personal profile. The profile includes fields such as full name, contact information, education background, work experience, skills, and an uploaded resume. The system shall allow the job seeker to update this information at any time.</li>
<li><strong>Job Search and Browsing:</strong> A job seeker shall be able to search for jobs using multiple criteria (e.g., keyword, job title, location, industry, salary range). The system shall provide filtering and sorting options for search results (for example, sort by date posted or relevance). The search results will display key job details (title, company, location, date posted) and the seeker can click to view a full job description.</li>
<li><strong>Job Application:</strong> For any posted job, a job seeker shall be able to submit an application through the system. The application will include the seeker’s profile information and resume (which can be attached or copied from their profile). The system shall record the application and notify the employer of the new application. A job seeker can apply to a job only once.</li>
<li><strong>Application Tracking:</strong> The system shall provide a “My Applications” section for job seekers. Here, the seeker can view all jobs they have applied to, along with the status of each application (e.g., applied, under review, hired, rejected). The status will be updated by the employer or system (for example, if an employer moves the application to a different stage).</li>
<li><strong>Save Jobs and Alerts:</strong> A job seeker shall be able to save or bookmark interesting job postings for later reference. The system shall maintain a “Saved Jobs” list for each seeker. Additionally, the system shall allow job seekers to set up job alerts: the seeker can define criteria (e.g., “software engineer jobs in California”), and the system will send periodic notifications (email or in-app) when new jobs matching those criteria are posted.</li>
<li><strong>Communication:</strong> A job seeker shall be able to receive messages from employers through the system (for example, an invitation to interview). The seeker can view and reply to these messages within the portal. The system will send email notifications for new messages if the user is not logged in. Job seekers can also send messages to employers through the job listing page (e.g., to inquire about the job before applying).</li>
</ul>
</li>
<li><strong>Employer Functions:</strong>
<ul>
<li><strong>Company Profile Management:</strong> An employer (which could represent a company or recruitment agency) shall create and manage a company profile. The company profile includes details such as company name, description, industry, location, website, and logo. Employers can edit this profile at any time to keep information current.</li>
<li><strong>Job Posting:</strong> An employer shall be able to post a new job opening. The job posting form will require fields like job title, job type (full-time, part-time, etc.), location, job description, required qualifications, salary range (optional), and application deadline (optional). The system shall validate that required fields are filled and allow the employer to publish the job after review. Employers can save a job as a draft and publish it later if needed.</li>
<li><strong>Job Management:</strong> The system shall provide an interface for employers to manage their posted jobs. This includes viewing all active and past job postings, editing job details (if the job is not yet filled), closing a job (marking it as filled or expired), and deleting a job (if needed). The system will automatically close jobs that reach their application deadline.</li>
<li><strong>Candidate Search:</strong> Employers shall be able to search the database of job seeker profiles. They can search by keywords (skills, experience, education) or filter by criteria (location, years of experience, etc.). The system will return a list of candidate profiles matching the search. Employers can view the full profile and resume of any candidate (subject to the candidate’s privacy settings) and save interesting candidates for later.</li>
<li><strong>Application Management:</strong> For each job they posted, employers shall see a list of applicants (with their profiles and resumes attached). The employer can review applications, sort them (for example, by date applied or by a matching score), and assign statuses to each application (e.g., “New”, “Reviewed”, “Interviewing”, “Hired”, “Rejected”). The system shall update the application status visible to the candidate accordingly. Employers can also leave internal notes on applications for their reference.</li>
<li><strong>Communication:</strong> An employer shall be able to send messages to job seekers who have applied to their jobs or to any candidate whose profile they have access to. For example, an employer can message a candidate to schedule an interview or to inform them they were not selected. The system’s messaging interface will ensure these communications are tracked. Employers will also receive messages from job seekers (such as inquiries about the job), and they can reply through the system. All messages are stored in the system for both parties to reference.</li>
</ul>
</li>
<li><strong>Administrator Functions:</strong>
<ul>
<li><strong>User Account Management:</strong> The administrator shall have access to a user management interface. The admin can view all user accounts and their details. They can perform actions like activating/deactivating accounts (in case a user is violating terms or if there’s a spam account), merging duplicate accounts if needed, and resetting passwords for users in case of issues. The admin can also filter users by role (seekers or employers) to manage them separately.</li>
<li><strong>Content Moderation:</strong> The system shall allow the admin to monitor job postings and resumes. The admin can review any job posting that has been flagged by users or that the system flags as potentially violating content rules (e.g., containing offensive language). The admin can edit or remove inappropriate job postings. Similarly, if a resume is found to be spam or contains confidential information, the admin can remove or restrict access to that resume. The admin can also view reports from users (for example, a job seeker can report a job posting as fraudulent, which goes to the admin for investigation).</li>
<li><strong>System Configuration:</strong> The administrator shall be able to configure certain system-wide settings. This includes setting up categories for jobs (e.g., IT, Healthcare, Education), defining default email templates (for notifications like account verification, password reset, new job alert), and managing site-wide announcements or banners. The admin can also monitor system statistics such as total number of registered users, number of active jobs, and number of applications made, which helps in assessing the platform’s usage.</li>
<li><strong>Support and Maintenance:</strong> The admin interface will include tools for basic system maintenance. For example, the admin can generate backup of the database, restore from a backup if needed, and update the system software (if the system is modular, the admin might trigger updates for different components). The admin will also handle user support queries – users can contact support through the portal, and the admin can respond or escalate issues. This ensures that any technical problems or user disputes are addressed in a timely manner.</li>
</ul>
</li>
</ul>
<p>Each of these functional requirements will be further detailed in the system design and implementation. They serve as the foundation for the features that will be built. By clearly defining these functions, we ensure that the development team and stakeholders have a common understanding of what the system will do.</p>
<h3 id="25-non-functional-requirements">2.5 Non-Functional Requirements</h3>
<p>In addition to the functional requirements, the Online Job Portal System must meet several non-functional requirements (NFRs) that define how the system should perform and behave. Non-functional requirements address aspects such as performance, security, usability, reliability, and scalability. These requirements are crucial for ensuring the system is not only correct in functionality but also efficient and user-friendly. The key non-functional requirements for our project are:</p>
<ul>
<li><strong>Performance:</strong> The system should respond quickly to user actions even as the user base grows. Specifically, typical web requests (such as loading a page or searching for jobs) should complete within 2 seconds under normal load. The system should be able to handle at least 100 concurrent users without significant slowdowns. Database queries for search and retrieval of data should be optimized (using indexing, caching, etc.) to ensure fast response times. The system will also be expected to handle peak loads (for example, a surge in traffic when new jobs are posted or during job fair events) without crashing or degrading performance severely. We aim for an uptime of at least 99% (meaning the system should be available and responsive 99% of the time, allowing for minimal downtime for maintenance).</li>
<li><strong>Usability:</strong> The system’s user interface should be intuitive and easy to use for people with varying levels of technical expertise. The design will follow common web conventions so that users can navigate without extensive training. The layout and forms will be clean and uncluttered, with clear labels and instructions. We will incorporate user-centered design principles – for instance, providing feedback for actions (like a confirmation message after applying to a job) and guiding users through multi-step processes (such as account setup or job posting) with clear steps. The interface will be responsive, meaning it will adapt to different screen sizes (desktop, laptop, tablet, mobile) to provide a good experience on all devices. Usability testing will be conducted with a sample of target users to identify any confusion points, and the interface will be refined based on their feedback. The goal is to achieve a high usability rating (e.g., a System Usability Scale score above 80) in testing.</li>
<li><strong>Security:</strong> Security is paramount since the system handles sensitive personal and professional data. All sensitive data stored in the database (such as passwords, addresses, contact info) will be encrypted or hashed appropriately. We will implement secure authentication mechanisms – passwords will be hashed using strong algorithms, and we will use HTTPS for all communications to prevent eavesdropping on data in transit. The system will have role-based access control to ensure that users can only access the data they are authorized to (for example, an employer cannot view another employer’s applicants, and a job seeker cannot modify any data except their own). We will also put in measures to prevent common web vulnerabilities: input validation to prevent SQL injection and cross-site scripting (XSS) attacks, and protection against CSRF (Cross-Site Request Forgery) in forms. Additionally, the system will have an audit trail for administrative actions (e.g., log when an admin deletes a user or job) to ensure accountability. Regular security audits and penetration testing will be performed (especially before deployment and periodically thereafter) to identify and fix any vulnerabilities. Compliance with data protection laws (like GDPR for European users) will be ensured, meaning users will have control over their data and the system will allow data deletion and provide privacy notices.</li>
<li><strong>Reliability:</strong> The system should be reliable, meaning it should perform its required functions consistently and without failure under normal conditions. Data integrity is crucial – the system will use database transactions to ensure that operations like applying to a job (which involves multiple steps) either complete fully or roll back completely, preventing partial updates. We will implement backup procedures for the database; critical data will be backed up daily and stored securely, so that in the event of data loss (due to hardware failure or other issues), we can restore the system with minimal loss. The system will also have error handling mechanisms – if an unexpected error occurs, the system should handle it gracefully (for example, display a friendly error message to the user and log the error for the developers) rather than crashing. We will aim for robust reliability such that major failures are rare. In the unlikely event of a system failure, the Mean Time To Recovery (MTTR) should be short – ideally, any unplanned downtime should be resolved within a few hours. Redundancy may be introduced in the deployment (such as having a backup server) to further improve reliability for critical components.</li>
<li><strong>Scalability:</strong> The architecture of the system will be designed to scale as the user base and data volume grow. This means that if the number of users or job postings increases significantly, the system can be scaled horizontally (by adding more servers or instances) or vertically (by upgrading resources) to accommodate the load. The use of a modular design and possibly a microservices approach will allow us to scale different components independently (for example, if the search feature becomes a bottleneck, we can scale the search service separately). The database should be normalized and indexed to handle large tables (for instance, tens of thousands of users and jobs) efficiently. We will also consider implementing caching for frequently accessed data (like popular job listings or search results) to reduce database load. The system should support growth in both user count and usage intensity (e.g., more simultaneous users during peak times). By designing with scalability in mind, we ensure that the platform can grow with demand without a complete overhaul of the architecture.</li>
<li><strong>Maintainability:</strong> The system should be easy to maintain, update, and extend. This involves writing clean, well-documented code following software engineering best practices. The codebase will be organized into modules (for example, separate modules for user management, job postings, applications, etc.) so that changes in one area do not break other parts. We will use version control and follow an appropriate branching strategy to manage updates. The system will also be designed to allow new features to be added with minimal disruption – for instance, through the use of configuration files or plugin-like architecture for optional features. Comprehensive documentation (both technical and user documentation) will be provided. The development team will follow coding standards and perform code reviews to ensure quality. A logging and monitoring system will be in place to aid in troubleshooting – detailed logs of system activities and errors will help administrators diagnose issues quickly. By prioritizing maintainability, we ensure that the system can evolve over time (responding to new requirements or fixing bugs) in an efficient manner.</li>
</ul>
<p>These non-functional requirements will guide the design and implementation choices. For example, to meet performance and scalability requirements, we might choose a particular database technology or caching mechanism; to meet security requirements, we will integrate certain security libraries and practices. Ensuring these NFRs are met is just as important as the functional features, as they determine the overall quality and success of the system from the users’ perspective.</p>
<h2 id="chapter-3-system-analysis">Chapter 3: System Analysis</h2>
<h3 id="31-overview">3.1 Overview</h3>
<p>System analysis is the phase where we delve into the details of how the system will function, focusing on the structure and behavior of the proposed Online Job Portal System. Using the requirements gathered in the previous chapter, we will model the system using Unified Modeling Language (UML) diagrams. UML provides a standardized way to visualize the design of a software system, and we will use several types of diagrams to capture different aspects of our system. Specifically, we will create a <strong>use case diagram</strong> to show the high-level interactions between users and the system, a <strong>class diagram</strong> to depict the static structure of the system (the classes and their relationships), a <strong>sequence diagram</strong> to illustrate an example dynamic interaction (in this case, the job application process), and an <strong>activity diagram</strong> to model a workflow (such as the process of posting a job). These diagrams will help in understanding the system’s requirements from a design perspective and serve as a blueprint for the implementation.</p>
<p>In this chapter, we first present the use case diagram which summarizes the main functionalities (use cases) that each type of user will perform. Next, the class diagram will outline the key entities in the system and how they relate to each other, which is essential for designing the database and object model. The sequence diagram will then zoom in on one particular scenario (a job seeker applying to a job) to show the step-by-step interactions between the system components and users involved in that scenario. Finally, the activity diagram will show a flow of activities, such as how a job posting is processed from creation to publication. Together, these diagrams provide a comprehensive analysis of the system’s functional requirements and design, bridging the gap between what the system should do (requirements) and how it will do it (design).</p>
<p>By visually representing the system, we can identify any missing requirements or potential design issues early. For instance, the use case diagram might reveal an interaction we had not considered, or the sequence diagram might show a step that needs to be added to a process. These insights can be fed back to refine the requirements or design. The system analysis phase ensures that both the development team and stakeholders have a clear and shared understanding of the system’s architecture and behavior before moving on to the detailed system design and coding.</p>
<h3 id="32-use-case-diagram">3.2 Use Case Diagram</h3>
<p>The use case diagram for the Online Job Portal System illustrates the various interactions (use cases) that the three main actors (Job Seeker, Employer, and Administrator) have with the system. Each use case represents a specific goal or task that a user can perform through the system. The diagram shows the scope of the system and how different users are involved in different functionalities.</p>
<p>In the use case diagram, the <strong>Job Seeker</strong> actor is associated with use cases such as <em>Register Account</em>, <em>Edit Profile</em>, <em>Search Jobs</em>, <em>Apply to Job</em>, <em>Save Job</em>, and <em>View Application Status</em>. These correspond to the key tasks a job seeker would do: creating an account, updating their profile, searching for jobs, submitting applications, bookmarking jobs for later, and checking on the status of their applications. The <strong>Employer</strong> actor is linked to use cases including <em>Post Job</em>, <em>Edit Job Posting</em>, <em>Search Candidates</em>, <em>Manage Applications</em>, and <em>Send Message</em>. This reflects that employers can post job openings, modify existing postings, search the pool of candidates, manage the applications they receive (review and update statuses), and communicate with applicants. The <strong>Administrator</strong> actor is connected to use cases like <em>Manage User Accounts</em>, <em>Moderate Content</em>, and <em>Configure System</em>, indicating the administrative tasks of overseeing user accounts, moderating job postings and resumes, and handling system-wide settings.</p>
<p>Relationships between use cases are also shown where appropriate. For example, the <em>Edit Profile</em> use case might be a generalization of a more specific use case like <em>Update Contact Information</em> (though not explicitly shown in this summary, such hierarchical relationships can be used to avoid redundancy). In some cases, use cases may include or extend others – for instance, applying to a job might include the use case of uploading a resume if that is a distinct step. The use case diagram provides a high-level view that all stakeholders can understand, confirming that we have captured all the necessary functionalities for each user type. It also helps in identifying any overlaps or gaps; for instance, if we missed a use case that a user needs, it would be evident that an actor is not connected to that functionality. This diagram serves as a foundation for more detailed use case descriptions and for the other UML diagrams that follow.</p>
<figure style="text-align: center;">
<img alt="Use case diagram for the online job portal system" src="https://agents-download.skywork.ai/image/rt/4d064b026d87e5c09f7844bcf5459d13.jpg" style="max-height: 280px; max-width: 50vw;"/>
<figcaption>Use Case Diagram for Online Job Portal System with actors: Job Seeker, Employer, Administrator</figcaption>
</figure>
<h3 id="33-class-diagram">3.3 Class Diagram</h3>
<p>The class diagram for the Online Job Portal System shows the static structure of the system’s classes and the relationships between them. This diagram is an important part of the object-oriented design, as it models the core entities in the system and how they interact. In our job portal, the key classes (entities) identified are <strong>User</strong>, <strong>JobSeeker</strong>, <strong>Employer</strong>, <strong>JobListing</strong>, <strong>Application</strong>, and <strong>Message</strong>. These classes encapsulate the data and behavior needed to support the system’s functionality.</p>
<p>The <strong>User</strong> class is a general class representing any user of the system. It contains attributes common to all users, such as <code>userID</code>, <code>username</code>, <code>email</code>, and <code>passwordHash</code>. It also has a <code>role</code> attribute indicating whether the user is a job seeker, employer, or admin. The <strong>JobSeeker</strong> and <strong>Employer</strong> classes inherit from <code>User</code> (indicated by a generalization relationship), meaning they inherit the attributes and methods of <code>User</code> and add their own specific attributes. The <code>JobSeeker</code> class includes attributes like <code>resume</code> (perhaps storing a reference to a file or the text of the resume), <code>skills</code>, and <code>education</code>, which are relevant to a job seeker’s profile. The <code>Employer</code> class has attributes such as <code>companyName</code>, <code>companyDescription</code>, and <code>companyLocation</code>, representing the company or organization the employer belongs to.</p>
<p>The <strong>JobListing</strong> class represents a job posting made by an employer. It contains attributes like <code>jobID</code>, <code>title</code>, <code>description</code>, <code>location</code>, <code>salaryRange</code>, and <code>postDate</code>. There is a one-to-many relationship from <code>Employer</code> to <code>JobListing</code> (an employer can post many jobs, and each job is posted by one employer), which is modeled by the <code>postedJobs</code> association. This indicates that an <code>Employer</code> object will have a collection of <code>JobListing</code> objects that they have posted.</p>
<p>The <strong>Application</strong> class represents an application submitted by a job seeker for a particular job. It has attributes such as <code>applicationID</code>, <code>applicationDate</code>, and <code>status</code> (which might be an enumeration like “Applied”, “Reviewed”, “Interview”, “Hired”, “Rejected”). The <code>Application</code> class has associations to both <code>JobSeeker</code> and <code>JobListing</code>: each application is made by one job seeker for one job listing. This is a many-to-many relationship between <code>JobSeeker</code> and <code>JobListing</code> mediated by the <code>Application</code> class (a job seeker can apply to many jobs, and a job can receive applications from many seekers). The associations are named <code>applications</code> (from <code>JobSeeker</code> to <code>Application</code>) and <code>applicants</code> (from <code>JobListing</code> to <code>Application</code>), making the relationships explicit.</p>
<p>Finally, the <strong>Message</strong> class models the communication between users. It includes attributes like <code>messageID</code>, <code>content</code>, <code>timestamp</code>, and possibly <code>isRead</code> status. A message is sent by one user and received by another, so <code>Message</code> has associations to the <code>User</code> class (twice: one for <code>sender</code> and one for <code>receiver</code>). This indicates that each message has a single sender and a single receiver, both of which are <code>User</code> objects (which could be a <code>JobSeeker</code> or <code>Employer</code> in practice). The association names <code>sentMessages</code> and <code>receivedMessages</code> on the <code>User</code> side show that a user can send and receive multiple messages.</p>
<p>The class diagram also shows some example methods for the classes. For instance, the <code>JobSeeker</code> class might have a method <code>applyToJob(JobListing job)</code> which handles the logic of creating an application. The <code>Employer</code> class might have a method <code>postJob(String title, ...)</code> to create a new job listing. The <code>JobListing</code> class could have methods like <code>addApplicant(Application app)</code> to add an application to its list of applicants, and <code>closeJob()</code> to mark the job as closed. These methods are not exhaustive but illustrate the kind of behavior each class encapsulates. In the actual implementation, these classes will be realized as database tables (for storing data) and as objects in the application code (with the associated business logic methods).</p>
<p>By defining this class structure, we establish the foundation for the database design (each class corresponds to a table, and associations correspond to foreign keys or join tables) and for the object-oriented implementation. The class diagram ensures that all important entities are accounted for and that their relationships are clearly defined, which helps prevent inconsistencies in the system. For example, since we know an <code>Application</code> links a <code>JobSeeker</code> and a <code>JobListing</code>, we can design the database such that each application record has a seeker ID and a job ID as foreign keys. This diagram also provides a common vocabulary for the development team to refer to when building the system, ensuring everyone understands the structure of the data being managed.</p>
<figure style="text-align: center;">
<img alt="Class diagram for the online job portal system" src="https://agents-download.skywork.ai/image/rt/52b825c39f4fb2cd328d006835aeaa0a.jpg" style="max-height: 280px; max-width: 50vw;"/>
<figcaption>Class Diagram for Online Job Portal System showing main classes and relationships</figcaption>
</figure>
<h3 id="34-sequence-diagram">3.4 Sequence Diagram</h3>
<p>The sequence diagram illustrates a specific scenario of how the Online Job Portal System will function, focusing on the dynamic interaction between objects. In this example, we model the <strong>job application process</strong>: a job seeker finds a job listing and submits an application through the system. The sequence diagram shows the order of messages exchanged between the involved actors and objects, providing a detailed view of this workflow.</p>
<p>In the sequence diagram, the participants (actors and objects) are listed along the top, each with a vertical lifeline extending downward. The horizontal arrows between lifelines represent messages (calls or interactions) in the order they occur. For the job application scenario, the main participants are the <strong>Job Seeker</strong> (actor), the <strong>JobListing</strong> object (the specific job being applied to), the <strong>Application</strong> object (which will be created for this application), the <strong>JobSeeker</strong> object (representing the seeker’s data in the system), and the <strong>Employer</strong> object (the employer who posted the job). Time flows from top to bottom, so the first message is at the top.</p>
<p>The scenario begins when the <strong>Job Seeker</strong> decides to apply to a job. They initiate the process by sending a message to the <strong>JobListing</strong> (perhaps through the user interface, which internally calls a method on the JobListing object) to indicate they want to apply. Let’s denote this message as <em>apply()</em>. Upon receiving the apply request, the <strong>JobListing</strong> object will create a new <strong>Application</strong> instance to record this application. We show a message from <code>JobListing</code> to <code>Application</code> labeled <em>createApplication(JobSeeker)</em>, which signifies that the job listing is creating an application associated with the current job seeker. The <code>Application</code> object is initialized with details such as the job seeker, the job, and the current timestamp.</p>
<p>Next, the <strong>Application</strong> needs to be linked to both the job seeker and the job listing in their respective data structures. The sequence diagram shows the <code>Application</code> sending a message to the <strong>JobSeeker</strong> object: <em>addApplication(Application)</em>. This message tells the job seeker to add this application to their list of applications (so the seeker can track it later). Similarly, the <code>Application</code> sends a message to the <strong>JobListing</strong> object: <em>addApplicant(Application)</em>, which adds the application to the job listing’s list of applicants (so the employer can see it). These steps ensure that both sides of the relationship are updated.</p>
<p>After the application is created and added, the system typically needs to notify the employer about the new application. We represent this by a message from the <strong>Application</strong> to the <strong>Employer</strong> object: <em>notifyNewApplication()</em>. This could correspond to an internal method call that triggers a notification – in practice, this might result in an email being sent to the employer or an in-app alert. The employer’s side (the <code>Employer</code> object) then may perform an action like <em>updateDashboard()</em> to reflect that there is a new application to review (this is a high-level representation; in reality, the system might just log the notification or queue an email task).</p>
<p>Finally, since the user (Job Seeker) should receive confirmation, the sequence diagram shows a response message going back to the user interface (often, the <code>JobSeeker</code> actor). This could be represented as <em>Application Successful</em> or a confirmation event. In the diagram, this might be shown as a return message from the <code>JobListing</code> or <code>Application</code> indicating success, which the UI then conveys to the user.</p>
<p>Throughout the sequence, we can also note any guard conditions or alternate flows. For instance, if the job seeker had already applied to that job, the system should not allow a duplicate application. That could be modeled as an alternate path: when the <code>apply()</code> message is received, the <code>JobListing</code> checks if an application from this seeker already exists; if yes, it might return an error message instead (this is a possible extension to the basic sequence shown).</p>
<p>The sequence diagram provides a clear timeline of how the system components interact for the job application use case. It verifies that we have considered all necessary steps: creating the application record, updating both the seeker’s and job’s data, and notifying the relevant parties. This level of detail helps in identifying any missing interactions – for example, if we forgot to include the step of adding the application to the job seeker’s list, it would be obvious in the diagram that the seeker never gets a reference to their new application. By walking through the scenario in this visual way, we can also plan how to implement it in code, understanding the order of operations and which objects need to communicate with each other. In summary, the sequence diagram enriches our system analysis by detailing a critical workflow, ensuring that the design supports the functional requirements of the use case.</p>
<figure style="text-align: center;">
<img alt="Sequence diagram for the job application process" src="https://agents-download.skywork.ai/image/rt/88befe4ba868d26ed0c3ab7d85586788.jpg" style="max-height: 280px; max-width: 50vw;"/>
<figcaption>Sequence Diagram for job application process in Online Job Portal System</figcaption>
</figure>
<h3 id="35-activity-diagram">3.5 Activity Diagram</h3>
<p>The activity diagram models the workflow of a process in the Online Job Portal System as a sequence of activities. It is a behavioral diagram that shows the flow of control from one activity to another. In this example, we present an activity diagram for the <strong>job posting process</strong> from the perspective of an employer. This diagram will illustrate the steps an employer takes to post a new job and the decisions or branches that may occur during this process.</p>
<p>The activity diagram starts with an initial node (a solid black circle) which transitions into the first activity: <strong>Employer logs in</strong>. This represents the employer signing into the system. The next activity is <strong>Navigate to Post Job</strong>, meaning the employer goes to the interface for creating a new job listing. Following that, the employer performs the activity <strong>Fill in job details</strong> – this is where they input all the required information for the job (title, description, etc.). Once the details are filled, there is a decision node (diamond shape) labeled <strong>All required fields filled?</strong>. The system checks if the employer provided all mandatory information for the job posting. If any required field is missing, the workflow branches to the activity <strong>Show error and prompt correction</strong>, after which it loops back to <strong>Fill in job details</strong> so the employer can fix the omissions. This loop continues until all required fields are correctly filled.</p>
<p>When all required fields are filled, the workflow proceeds to the activity <strong>Submit job posting</strong>. At this point, the employer has completed the form and submitted the job. Another decision node comes next: <strong>Moderation required?</strong> This represents a policy decision in the system – perhaps new job postings need to be approved by an administrator before they go live (moderation), or they can be published immediately. In our diagram, we consider a scenario where moderation is enabled for at least some postings (for example, to filter out spam or ensure quality). If moderation is required, the job posting is sent to the <strong>Administrator for review</strong>. The administrator then performs the activity <strong>Review job posting</strong>. After reviewing, the administrator makes a decision: <strong>Approve or Reject?</strong>. If approved, the job is <strong>Published on portal</strong>. If rejected, the job is <strong>Discarded/Returned to employer</strong> (perhaps with feedback). In the case where moderation is not required (or after approval), the job is published, and the workflow reaches an activity <strong>Job is live on portal</strong>, indicating that the job listing is now visible to job seekers. The final node (a solid black circle surrounded by a circle) signifies the end of the process.</p>
<p>This activity diagram clearly outlines the flow and possible paths. It shows that the normal successful path is: login → navigate to post → fill details (with possible correction loop) → submit → (if no moderation or after approval) → publish. The alternate paths include the correction loop for missing fields and the rejection path if the admin does not approve the job. The diagram also highlights the involvement of the administrator as a separate swimlane or role in the process (though in our simplified text description we mentioned it, in a visual diagram this might be shown by partitioning the diagram into swimlanes for “Employer” and “Administrator”).</p>
<p>By creating this activity diagram, we ensure that we have accounted for all steps and decision points in the job posting process. It helps in understanding how the system will handle different scenarios – for example, what happens if an employer tries to post an incomplete job, or how an admin approval workflow would integrate. This can inform the implementation of validation checks and any approval interface for admins. The activity diagram also serves as a communication tool for stakeholders to review the business process. If, for instance, stakeholders decide that no admin moderation is needed (all jobs can be published immediately), that change can be reflected by removing the moderation decision and admin review steps from the diagram and the system design. In summary, the activity diagram for job posting provides a visual workflow analysis that complements the use case and sequence diagrams, ensuring the system’s processes are well-understood and correctly implemented.</p>
<figure style="text-align: center;">
<img alt="Activity diagram for the job posting process" src="https://agents-download.skywork.ai/image/rt/5ad1b5388e4739c2dd1e452670b31450.jpg" style="max-height: 280px; max-width: 50vw;"/>
<figcaption>Activity Diagram for job application process in Online Job Portal System</figcaption>
</figure>
<h2 id="chapter-4-system-design">Chapter 4: System Design</h2>
<h3 id="41-overview">4.1 Overview</h3>
<p>In this chapter, we move from analyzing the system to designing its architecture and components. The system design phase focuses on how the Online Job Portal System will be structured and implemented. We will describe the overall <strong>system architecture</strong>, which defines the high-level structure of the system, including the major components and how they interact. Additionally, we will provide a <strong>deployment diagram</strong> to show how the system will be deployed across hardware and software environments, a <strong>component diagram</strong> to illustrate the organization of software components and their interfaces, and a description of the <strong>persistent data model</strong> (database design) that will store the system’s data.</p>
<p>The system design is crucial as it bridges the gap between the abstract analysis models and the concrete implementation. It translates the requirements and analysis into a blueprint that developers can follow to build the system. A good design ensures that the system will meet its requirements (both functional and non-functional) and will be maintainable, scalable, and reliable. We will adhere to software design principles such as separation of concerns, modularity, and scalability in our design decisions.</p>
<p>First, we outline the system architecture, explaining the pattern or style chosen (for example, a layered architecture or client-server architecture) and the reasoning behind it. Next, the deployment diagram will give a picture of the physical setup – for instance, how the web server, application server, and database server are arranged, and what technologies they use. The component diagram will then zoom in on the software side, detailing the key modules or components of the application (like user management module, job search module, etc.) and how they communicate with each other. Finally, we describe the database design, including the main tables, their structure, and the relationships between them, which is derived from the class diagram and ensures that we can persist all necessary data.</p>
<p>Throughout this chapter, we will reference the requirements and analysis from earlier chapters to ensure traceability – for example, explaining how the chosen architecture supports the performance and scalability requirements, or how the component breakdown corresponds to the use cases. By the end of this chapter, we will have a clear plan for implementing the Online Job Portal System, covering both the logical design (how the software is structured) and the physical design (how it will be deployed and run).</p>
<h3 id="42-system-architecture">4.2 System Architecture</h3>
<p>The Online Job Portal System will be built using a <strong>multi-tier architecture</strong>, specifically a three-tier client-server architecture. This architecture divides the application into three logical layers: the <strong>presentation layer</strong>, the <strong>application (business logic) layer</strong>, and the <strong>data layer</strong>. Separating the system into layers provides several benefits, including modularity, easier maintenance, and scalability, as each layer can be developed, updated, and scaled independently (<a href="https://www.reddit.com/r/cscareerquestions/comments/1lnvq1g/whats_a_good_tech_stack_in_this_market_to_learn/" target="_blank">[reddit.com]</a>). The following diagram illustrates this architecture.</p>
<div class="chart-wrapper" id="chart10"></div>
<div class="data-source">Data Source: Synthesized from <a href="https://www.reddit.com/r/cscareerquestions/comments/1lnvq1g/whats_a_good_tech_stack_in_this_market_to_learn/" target="_blank">[Reddit]</a>, <a href="https://www.ijsat.org/research-paper.php?id=6188" target="_blank">[IJSAT]</a>, <a href="https://www.slideshare.net/slideshow/online-job-portal-system/25263743" target="_blank">[Slideshare]</a></div>
<p><strong>Presentation Layer (Client Tier):</strong> This is the top layer that interacts with the end-users. It consists of the <strong>web user interface</strong> that job seekers, employers, and administrators use to access the system. The presentation layer is implemented using web technologies: HTML5, CSS3, and JavaScript for the front-end. We plan to use a modern JavaScript framework such as <strong>React</strong> or <strong>Angular</strong> to build a dynamic and responsive user interface (<a href="https://www.reddit.com/r/cscareerquestions/comments/1lnvq1g/whats_a_good_tech_stack_in_this_market_to_learn/" target="_blank">[reddit.com]</a>). This layer handles user input and displays the results returned by the application layer. For example, when a user searches for jobs, the presentation layer sends the search request to the server and then renders the results on the screen. The UI will be designed to be intuitive and consistent with the requirements gathered (following the usability guidelines from Chapter 2). Being a web application, the presentation layer runs in the user’s web browser (client side). We will ensure the UI is responsive and works well on different devices (desktop, tablet, mobile) by using responsive design techniques and possibly a mobile-first approach.</p>
<p><strong>Application Layer (Business Logic Tier):</strong> The middle layer is the application layer, also known as the backend or server layer. This layer contains the <strong>business logic</strong> of the Online Job Portal System and acts as the intermediary between the presentation layer and the data layer. The application layer is implemented on a web server using a server-side programming language and framework. There are several suitable technology choices for this layer; for example, a <strong>Python</strong> stack with <strong>Django</strong> or <strong>Flask</strong>, a <strong>Java</strong> stack with <strong>Spring Boot</strong>, or a <strong>JavaScript/Node.js</strong> stack with <strong>Express</strong> or <strong>NestJS</strong> (<a href="https://www.reddit.com/r/cscareerquestions/comments/1lnvq1g/whats_a_good_tech_stack_in_this_market_to_learn/" target="_blank">[reddit.com]</a>). Each of these frameworks provides robust support for handling HTTP requests, implementing business rules, and interacting with databases. The choice may depend on team expertise and scalability needs; for instance, Node.js is known for handling high concurrency in I/O-bound applications, while Django offers a lot of built-in functionality (ORM, admin interface) out of the box (<a href="https://www.ijsat.org/research-paper.php?id=6188" target="_blank">[ijsat.org]</a>).</p>
<p>In the application layer, we will have various modules or components corresponding to different functionalities: a <strong>User Management module</strong> to handle registration, login, and profile updates, a <strong>Job Listing module</strong> to manage the creation and retrieval of job postings, an <strong>Application module</strong> to handle the application process and status tracking, a <strong>Search module</strong> to implement the job search and candidate search functionality (possibly using full-text search or an external search engine integration for efficiency), and a <strong>Communication module</strong> to handle messaging between users. These modules encapsulate the business rules (for example, validation logic for job postings, matching logic for search, etc.) and ensure that the system’s behavior aligns with the requirements. The application layer will also enforce security and authorization – for each incoming request, it checks that the user is authenticated and has permission to perform the requested action (e.g., only an employer can delete a job posting, etc.).</p>
<p>This layer communicates with the presentation layer via HTTP(S) protocols, typically using RESTful APIs. In a RESTful design, the application layer exposes a set of endpoints (URLs) for each operation (like <code>/api/jobs</code> for jobs, <code>/api/applications</code> for applications, etc.) and handles HTTP methods (GET, POST, PUT, DELETE) appropriately. The data is usually exchanged in JSON format. This API-based approach makes the system flexible; in the future, if we want to create a mobile app or another client, it can use the same backend APIs. Internally, the application layer may also communicate with external services if needed (for example, an email service to send notifications, or a payment gateway if we add paid features later), but those are beyond the initial scope.</p>
<p><strong>Data Layer (Database Tier):</strong> The bottom layer is the data layer, which is responsible for storing and retrieving the system’s data. We will use a <strong>relational database management system (RDBMS)</strong> for this project, such as <strong>MySQL</strong>, <strong>PostgreSQL</strong>, or <strong>SQL Server</strong>, to store structured data (<a href="https://www.slideshare.net/slideshow/online-job-portal-system/25263743" target="_blank">[slideshare.net]</a>). Relational databases are a good fit here because our data model (from the class diagram) has well-defined relationships (one-to-many, many-to-many) and we need to ensure data integrity (using transactions and constraints). The database will host tables corresponding to the core entities: Users, JobSeekers, Employers, JobListings, Applications, Messages, and any other supporting tables (for example, a table for job categories or a lookup table for application statuses). We will design the database schema to accurately represent these entities and their relationships, which is detailed in Section 4.5 (Persistent Data Model). The data layer receives queries and commands from the application layer (via SQL statements, often executed through an ORM – Object-Relational Mapping – tool provided by the backend framework).</p>
<p>To support scalability and performance, the database may be optimized with indexes on frequently searched fields (such as job title, location, or user skills). We might also consider using connection pooling in the application layer to efficiently manage database connections. If the volume of data grows very large, we could explore scaling strategies like database sharding or read replicas, but those are future considerations; initially, a single database server should suffice.</p>
<p><strong>Additional Architectural Considerations:</strong> We will follow a <strong>modular and layered design</strong> within the application layer as well. For instance, we can separate the web server part (which handles HTTP routing and request/response) from the business logic and data access code. This can be done by using an <strong>MVC (Model-View-Controller)</strong> or <strong>MVP (Model-View-Presenter)</strong> pattern in the backend, where the Controller (or Presenter) handles user requests, the Model interacts with the database, and business logic is encapsulated in either the Model or separate service classes. Such patterns further organize the code and improve maintainability. Additionally, we might use design patterns like <strong>Repository</strong> for data access (to abstract the database queries) and <strong>Factory</strong> or <strong>Strategy</strong> patterns if we have varying algorithms (for example, different matching algorithms for job search could be swapped using a strategy pattern).</p>
<p>Given the requirement for scalability and future extensibility, there is also the option of a <strong>microservices architecture</strong> in the long run. In a microservices approach, each major functionality (user service, job service, application service, etc.) could be a separate service with its own API and possibly its own database. This can improve scalability and development speed for large-scale systems. However, for the initial implementation, a monolithic architecture (all components in one application) is simpler and adequate. We will design the code in a way that it could be split into microservices later if needed – for example, by keeping modules decoupled and communicating via well-defined interfaces. This gives us the flexibility to evolve the architecture as the project grows.</p>
<p>In summary, the chosen three-tier architecture provides a clear structure: users interact with the presentation layer, which talks to the application layer, which in turn interacts with the data layer. This separation ensures that changes in one layer (say, updating the UI or switching the database) can be done with minimal impact on the other layers, as long as the interface between them remains consistent. It also allows us to scale each layer independently: for instance, we could deploy multiple instances of the application layer behind a load balancer to handle more users, while the database layer could be scaled by using a more powerful server or adding read replicas. This architecture has been widely used in industry for web applications and is proven to be reliable and scalable when implemented correctly.</p>
<h3 id="43-deployment-diagram">4.3 Deployment Diagram</h3>
<p>The deployment diagram for the Online Job Portal System illustrates the physical deployment of the software components onto hardware nodes and the relationships between them. It shows how the system will be distributed across servers and what components run on each server. This diagram is especially useful for understanding the infrastructure setup and ensuring that we have considered all necessary elements for deployment, such as web servers, application servers, databases, and network connections.</p>
<p>In our deployment scenario, we envision a typical web application deployment on cloud infrastructure. The key hardware/software nodes in the deployment diagram are: a <strong>Client Machine</strong> (representing the user’s device and web browser), a <strong>Web Server</strong> node, an <strong>Application Server</strong> node, and a <strong>Database Server</strong> node. Communication between these nodes happens over a network (usually the Internet for the client to server part, and a local network or internal connection for server-to-server communication).</p>
<p>The <strong>Client Machine</strong> is where the presentation layer runs. This could be a user’s desktop computer, laptop, tablet, or smartphone with a web browser installed. The client machine sends HTTP requests to the web server and receives HTML/JavaScript responses which it renders for the user. In the deployment diagram, an artifact labeled <em>Online Job Portal Web App (Client)</em> might be shown on the client machine, representing the static web assets (HTML, CSS, JS) that are delivered to the client. The communication from the client to the server is shown with an arrow labeled <strong>HTTP/HTTPS</strong>, indicating that all traffic is over the HyperText Transfer Protocol (secured with SSL/TLS in production for security).</p>
<p>The <strong>Web Server</strong> node is typically a server machine (could be a cloud virtual machine or container) that hosts a web server software (such as <strong>Apache HTTP Server</strong> or <strong>Nginx</strong>). The web server’s role is to handle incoming HTTP requests from clients. In a typical setup, the web server can serve static content directly (like images, CSS, JavaScript files) and proxy dynamic requests to the application server. In the deployment diagram, we might show an artifact <em>Web Server (Nginx)</em> on this node. The web server is often placed behind a <strong>load balancer</strong> if we have multiple instances, but for simplicity, we assume a single web server for now. The load balancer (if present) would distribute traffic across multiple web/app server instances to improve availability and performance.</p>
<p>The <strong>Application Server</strong> node hosts the backend application – the business logic layer of our system. This server runs the application code (for example, a Node.js process or a Java servlet container or a Python WSGI server, depending on our tech stack). We can label this artifact as <em>Online Job Portal Backend</em>. This is where all the dynamic processing happens: handling API requests, executing business logic, and interacting with the database. The application server node communicates with the database server node via a database protocol (like MySQL protocol or ODBC/JDBC for SQL databases). In the diagram, this connection is shown with an arrow, perhaps labeled <strong>Database Connection (JDBC/ODBC)</strong> or simply the database type (e.g., <strong>MySQL</strong>). The application server might also send emails via an SMTP server or interact with other services, but those are auxiliary and may not be included in the core deployment diagram unless they are part of the deployment environment.</p>
<p>The <strong>Database Server</strong> node is where the database management system runs (for example, <strong>MySQL Server</strong> or <strong>PostgreSQL</strong>). It contains the <em>Online Job Portal Database</em> artifact, which is the actual database storing all the tables and data (users, jobs, applications, etc.). The database server is usually on a separate machine (or at least a separate process with its own resources) to isolate the heavy I/O and processing of the database from the application server. This separation also aids in security (we can restrict direct access to the database) and scalability (we can scale the database independently).</p>
<p>Additionally, we might include a <strong>Load Balancer</strong> node in the deployment if we plan to have multiple instances of the web or application servers. The load balancer sits in front of the web servers and distributes client requests evenly, improving performance and providing fault tolerance (if one server goes down, others can handle the load). The deployment diagram would show clients connecting to the load balancer, which then forwards requests to web server instances. For the scope of this project, a load balancer might not be immediately necessary, but it’s a common component in production deployments of any significant scale.</p>
<p>Another consideration is <strong>security</strong> in deployment: we would place the web server and application server in a <strong>DMZ (Demilitarized Zone)</strong> or a public subnet that clients can reach, while the database server would reside in a private subnet with access only allowed from the application server, not directly from the internet. Firewall rules and security groups would be configured to enforce this. The deployment diagram could represent these network boundaries with dashed lines or labeled network segments (e.g., “Public Network” for client to web server, “Private Network” for application to database).</p>
<p>We will also include any <strong>additional services</strong> that are part of the deployment. For example, if we use an in-memory cache like <strong>Redis</strong> to improve performance (caching frequent database queries or user sessions), we would have a Redis server node in the diagram. Or if we use a message queue for asynchronous tasks (like sending emails in the background), that would be another node. For simplicity, we assume a straightforward deployment; however, these enhancements can be added later as the system scales.</p>
<p>In summary, the deployment diagram shows that the Online Job Portal System will be deployed in a distributed manner across a client and multiple servers, each with specific roles. This setup ensures that the system is robust and scalable. By separating the web server, application server, and database, we can optimize each for its purpose and scale them independently. The deployment diagram serves as a guide for the DevOps team (or whoever is setting up the environment) to correctly install and configure each component. It also helps in understanding the system’s <strong>non-functional characteristics</strong>: for instance, the use of HTTPS ensures security, having separate servers improves performance and reliability, and so on. This diagram, along with the architecture description, gives a complete picture of how the system will be put together in the real world.</p>
<h3 id="44-component-diagram">4.4 Component Diagram</h3>
<p>The component diagram provides a high-level view of the <strong>software components</strong> of the Online Job Portal System and how they interact with each other. It focuses on the organization of the system’s implementation, showing the major modules (components) and their interfaces. This diagram helps in understanding the system’s structure from a developer’s perspective, illustrating how responsibilities are divided among components and how they communicate to fulfill the system’s functionality.</p>
<p>In the Online Job Portal System, we can identify several key components (modules) based on the functional areas and the architecture we described:</p>
<ul>
<li><strong>User Management Component:</strong> This component handles all aspects related to user accounts and profiles. It includes functionality for user registration, login authentication, password management, and profile editing. The User Management component exposes interfaces (APIs) for actions like <code>registerUser()</code>, <code>loginUser()</code>, <code>updateProfile()</code>, etc. Other components that need to access user information (such as checking if a user exists or retrieving a user’s details) will interact with this component through its interfaces. For example, when a job seeker applies to a job, the Application component will call an interface on the User Management component to verify the user’s existence and get their details.</li>
<li><strong>Job Listing Component:</strong> This component manages the lifecycle of job postings. It allows employers to create new job listings, retrieve existing ones (for display or editing), and delete or close jobs. It also handles the moderation of job postings if that feature is implemented. The interfaces provided by this component might include <code>createJobListing()</code>, <code>getJobListing()</code>, <code>updateJobListing()</code>, <code>deleteJobListing()</code>, and possibly <code>approveJobListing()</code> if admin approval is needed. The Job Listing component will interact with the Database component to store and fetch job data. It may also interact with the User Management component to ensure that only the employer who posted a job can modify it (checking user roles/permissions).</li>
<li><strong>Application Component:</strong> This component deals with job applications – the process of a job seeker applying to a job and the subsequent management of those applications. Its interfaces could be <code>submitApplication()</code>, <code>getApplicationsForJob()</code>, <code>getApplicationsForUser()</code>, <code>updateApplicationStatus()</code>, etc. When a job seeker submits an application, this component will coordinate between the User Management (to get seeker info), Job Listing (to get job info), and Database components to create an application record. It also enforces business rules such as a user can only apply once per job. The Application component likely interfaces with the Notification component as well (to trigger notifications to the employer about a new application).</li>
<li><strong>Search Component:</strong> The Search component provides search functionality for both jobs and candidates. It encapsulates the search algorithms and indexes. For job search, it might interface with the Job Listing component to get job data and then perform keyword matching or more advanced search (using full-text search on job titles and descriptions). For candidate search, it interfaces with the User Management (JobSeeker profiles) to retrieve candidate data and match against employer search criteria. The Search component exposes an interface like <code>searchJobs(keywords, filters)</code> and <code>searchCandidates(keywords, filters)</code>. This component could be optimized separately – for instance, it might use a dedicated search engine or library (like Elasticsearch or Lucene) under the hood. By having a separate Search component, we can improve performance and maintain search logic independently.</li>
<li><strong>Communication Component:</strong> This component handles the messaging system between users. It manages sending and receiving messages, storing them, and notifying users. Interfaces might include <code>sendMessage(sender, receiver, content)</code>, <code>getMessagesForUser(user)</code>, <code>markMessageAsRead(message)</code>, etc. The Communication component interacts with the User Management component to validate sender and receiver exist and are allowed to message each other, and with the Database component to persist messages. It also works with the Notification component to send out email or in-app notifications when a new message is received.</li>
<li><strong>Notification Component:</strong> This component is responsible for sending out notifications to users, which could be in-app notifications or emails. It might be triggered by other components (for example, the Application component triggers a notification when a new application is submitted, the Communication component triggers a notification when a new message is sent). The Notification component interfaces with external services like an email server (SMTP) or uses an email API. It could also manage in-app notifications by storing them in the database for users to see when they log in. Interfaces might be <code>sendEmailNotification(user, subject, body)</code> or <code>createInAppNotification(user, message)</code>. This component ensures that the system can inform users of important events asynchronously.</li>
<li><strong>Database Component:</strong> Although not a “software component” in the same sense as the others (since it’s more of an infrastructure component), the Database is shown in the component diagram as a component that provides data storage and retrieval services. It exposes interfaces for CRUD (Create, Read, Update, Delete) operations on the various tables. In practice, these interfaces might be implemented via an ORM or DAO classes in the application code. Other components interact with the Database component to persist or fetch data. For example, the User Management component will call database interfaces to save a new user record, the Job Listing component will call database interfaces to retrieve a list of jobs, etc. We can consider the Database component as providing a <code>DatabaseService</code> interface with methods like <code>insert()</code>, <code>query()</code>, <code>update()</code>, <code>delete()</code> which are used by other modules.</li>
</ul>
<p>In the component diagram, these components are represented as rectangles labeled with their names. The interfaces they provide are shown as small lollipop symbols on the component. Arrows between components indicate dependencies or usage: for instance, an arrow from the Application component to the Database component indicates that the Application component uses the Database component’s interface to store applications. Another arrow from the Application component to the Notification component indicates that Application uses Notification to send alerts.</p>
<p>We might also show <strong>deployment descriptors</strong> or artifacts if relevant – for example, if the system were to be deployed as separate services, each component could correspond to a separate service or module. In a microservices scenario, each of these components might run in its own process or service, communicating via APIs. In a monolithic scenario, they are modules within one application, but the component diagram still helps in understanding the internal structure.</p>
<p>The component diagram for the Online Job Portal System would thus illustrate how, for example, the <strong>Job Seeker UI</strong> (presentation layer) sends a request to the <strong>Job Listing Component</strong> to get job data, which in turn queries the <strong>Database Component</strong>; or how the <strong>Employer UI</strong> triggers the <strong>Application Component</strong> to update an application status, which then notifies the <strong>Notification Component</strong> to inform the job seeker. This modular view ensures that each major function is encapsulated in a component with well-defined interfaces, promoting loose coupling and high cohesion. It also helps in planning the development: different teams or developers can work on different components relatively independently, as long as they adhere to the interface contracts.</p>
<p>Additionally, the component diagram can highlight any <strong>third-party components</strong> or libraries we plan to use. For example, if we use a <strong>Security Framework</strong> component for handling authentication/authorization (like Spring Security or Passport.js), that could be shown as a component that User Management uses. Or a <strong>Logging component</strong> that all components use to log information. These cross-cutting components can be connected to all relevant modules.</p>
<p>In conclusion, the component diagram gives a blueprint of the software’s modular structure. It ensures that we have a logical breakdown of the system into manageable parts and that we have considered how those parts will interact. This diagram is particularly useful during the implementation phase, guiding how we structure our codebase (for instance, organizing code into packages or modules corresponding to these components). It also aids in understanding the impact of changes – if a certain component’s interface changes, we can see which other components depend on it and need to be updated. By designing the system in terms of components and their interfaces, we promote a clean, maintainable architecture that aligns with the requirements and supports future enhancements.</p>
<h3 id="45-persistent-data-model">4.5 Persistent Data Model</h3>
<p>The persistent data model of the Online Job Portal System defines how the system’s data will be stored in the database – essentially, the database schema design. This model is derived from the class diagram and functional requirements, and it ensures that all necessary information can be stored and retrieved efficiently. We will use a relational database approach, so our data model consists of tables, columns, primary keys, foreign keys, and relationships between tables. Below, we outline the main entities (tables) in the data model and their attributes, as well as the relationships between them.</p>
<p><strong>1. User Table:</strong> This table stores the basic information for all users of the system, including job seekers, employers, and the administrator. It serves as the base for user accounts. The main attributes are:
        - <code>user_id</code> (Primary Key): A unique identifier for each user (e.g., an auto-incrementing integer or a UUID).
        - <code>username</code>: A unique username chosen by the user or their email address.
        - <code>email</code>: The user’s email address, also unique.
        - <code>password_hash</code>: The hashed (and salted) password for authentication.
        - <code>role</code>: An indicator of the user’s role (e.g., 'job_seeker', 'employer', 'admin').
        - <code>created_at</code>: Timestamp when the user account was created.
        - <code>last_login</code>: Timestamp of the user’s last login (optional).
        - <code>is_active</code>: A boolean flag indicating if the user account is active (not banned or deleted).
        
        The <code>user_id</code> will be referenced as a foreign key in other tables to link records to a specific <strong>third-party components</strong> or libraries we plan to use. For example, if we use a <strong>Security Framework</strong> component for handling authentication/authorization (like Spring Security or Passport.js), that could be shown as a component that User Management uses. Or a <strong>Logging component</strong> that all components use to log information. These cross-cutting components can be connected to all relevant modules.</p>
<p>In conclusion, the component diagram gives a blueprint of the software’s modular structure. It ensures that we have a logical breakdown of the system into manageable parts and that we have considered how those parts will interact. This diagram is particularly useful during the implementation phase, guiding how we structure our codebase (for instance, organizing code into packages or modules corresponding to these components). It also aids in understanding the impact of changes – if a certain component’s interface changes, we can see which other components depend on it and need to be updated. By designing the system in terms of components and their interfaces, we promote a clean, maintainable architecture that aligns with the requirements and supports future enhancements.</p>
<h3 id="45-persistent-data-model">4.5 Persistent Data Model</h3>
<p>The persistent data model of the Online Job Portal System defines how the system’s data will be stored in the database – essentially, the database schema design. This model is derived from the class diagram and functional requirements, and it ensures that all necessary information can be stored and retrieved efficiently. We will use a relational database approach, so our data model consists of tables, columns, primary keys, foreign keys, and relationships between tables. Below, we outline the main entities (tables) in the data model and their attributes, as well as the relationships between them.</p>
<p><strong>1. User Table:</strong> This table stores the basic information for all users of the system, including job seekers, employers, and the administrator. It serves as the base for user accounts. The main attributes are:
        - <code>user_id</code> (Primary Key): A unique identifier for each user (e.g., an auto-incrementing integer or a UUID).
        - <code>username</code>: A unique username chosen by the user or their email address.
        - <code>email</code>: The user’s email address, also unique.
        - <code>password_hash</code>: The hashed (and salted) password for authentication.
        - <code>role</code>: An indicator of the user’s role (e.g., 'job_seeker', 'employer', 'admin').
        - <code>created_at</code>: Timestamp when the user account was created.
        - <code>last_login</code>: Timestamp of the user’s last login (optional).
        - <code>is_active</code>: A boolean flag indicating if the user account is active (not banned or deleted).
        
        The <code>user_id</code> will be referenced as a foreign key in other tables to link records to a specific user. This table follows from the <code>User</code> class in our class diagram.</p>
<p><strong>2. JobSeeker Table:</strong> This table contains additional information specific to job seekers, beyond the generic user data. It has a one-to-one relationship with the User table (each job seeker is a user, and each user with role 'job_seeker' has one job seeker record). The attributes are:
        - <code>job_seeker_id</code> (Primary Key): Unique ID for the job seeker (could be the same as <code>user_id</code> if we use the user_id as the primary key here, or a separate ID that references user_id).
        - <code>user_id</code> (Foreign Key to User): Links to the User table, establishing the one-to-one relationship.
        - <code>full_name</code>: The full name of the job seeker.
        - <code>date_of_birth</code>: Date of birth (optional).
        - <code>education</code>: Information about education (could be stored as text or JSON describing degrees, institutions, etc.).
        - <code>experience</code>: Information about work experience (again, could be structured text or JSON listing previous jobs).
        - <code>skills</code>: A list or text field of skills possessed by the job seeker (this could be a separate Skills table with a many-to-many relationship if we want to index and search skills efficiently, but for simplicity here we might store as a comma-separated string or JSON array).
        - <code>resume</code>: A reference to the resume file (could be a file path or a binary field storing the resume document, or more likely a URL if resumes are stored in a cloud storage).
        - <code>contact_number</code>: Phone number (optional).
        
        This table corresponds to the <code>JobSeeker</code> class. All job seeker specific data (education, experience, skills, resume) are kept here so that the User table remains generic. By having a separate JobSeeker table, we avoid having many null fields in the User table for users who are employers.</p>
<p><strong>3. Employer Table:</strong> This table contains information specific to employers (companies or recruiters). Like JobSeeker, it has a one-to-one relationship with User. Attributes:
        - <code>employer_id</code> (Primary Key): Unique ID for the employer.
        - <code>user_id</code> (Foreign Key to User): Links to the User table.
        - <code>company_name</code>: The name of the company the employer represents.
        - <code>company_description</code>: A description of the company (optional).
        - <code>industry</code>: The industry of the company (optional, could be a code or text).
        - <code>company_size</code>: Number of employees or size category (optional).
        - <code>location</code>: The headquarters location or main office address of the company (optional).
        - <code>website_url</code>: URL of the company’s website (optional).
        - <code>contact_person</code>: Name of the contact person (the employer user) within the company (optional, if different from the user’s name).
        - <code>contact_email</code>: Contact email for the company (could default to the user’s email, but can be different if specified).
        - <code>contact_phone</code>: Contact phone number for the company (optional).
        
        This corresponds to the <code>Employer</code> class. It stores company-related data that employers provide, which helps job seekers learn about the company. Each employer user will have one record here.</p>
<p><strong>4. JobListing Table:</strong> This table represents the job postings in the system. Each row is a job opening posted by an employer. Attributes:
        - <code>job_id</code> (Primary Key): Unique ID for the job listing.
        - <code>employer_id</code> (Foreign Key to Employer): Indicates which employer posted the job (since Employer has a user_id, this ultimately links to a User as well).
        - <code>title</code>: Job title (e.g., “Software Engineer”).
        - <code>description</code>: Detailed description of the job responsibilities, requirements, etc.
        - <code>requirements</code>: List of required qualifications or skills (could be part of description or a separate field).
        - <code>location</code>: Location of the job (city, state, country; could be multiple if remote or multiple locations).
        - <code>job_type</code>: Type of employment (full-time, part-time, contract, internship, etc.).
        - <code>salary_min</code> and <code>salary_max</code>: Range of salary offered (optional, can be null if not disclosed).
        - <code>currency</code>: Currency of the salary (if provided).
        - <code>post_date</code>: Date and time when the job was posted.
        - <code>expiry_date</code>: Date when the job posting will expire/close (optional; jobs can also be closed manually).
        - <code>is_active</code>: Boolean indicating if the job is currently active (open for applications) or closed.
        - <code>application_deadline</code>: Optional deadline by which applications must be received.
        
        This table corresponds to the <code>JobListing</code> class. The <code>employer_id</code> foreign key enforces that each job is associated with one employer. We might add indexes on fields like <code>title</code>, <code>location</code>, <code>post_date</code>, and possibly a full-text index on <code>description</code> and <code>requirements</code> to facilitate fast search queries by job seekers.</p>
<p><strong>5. Application Table:</strong> This table records each application that a job seeker submits to a job. It establishes a many-to-many relationship between JobSeekers and JobListings (a seeker can apply to many jobs, and a job can have many applicants). Attributes:
        - <code>application_id</code> (Primary Key): Unique ID for the application.
        - <code>job_seeker_id</code> (Foreign Key to JobSeeker): Identifies the job seeker who applied.
        - <code>job_id</code> (Foreign Key to JobListing): Identifies the job they applied to.
        - <code>application_date</code>: Date and time when the application was submitted.
        - <code>status</code>: Current status of the application (e.g., 'applied', 'shortlisted', 'interview scheduled', 'hired', 'rejected'). This could be an ENUM type or a string, and we may have a separate lookup table for allowed statuses.
        - <code>cover_letter</code>: Optional cover letter text that the job seeker provided with the application.
        - <code>resume_used</code>: Reference to the resume file used for this application (this might just be a copy of the job seeker’s latest resume; it could be redundant if we always use the latest resume from JobSeeker table, but some systems allow attaching a specific version of resume, so we include it here as optional).
        
        This table corresponds to the <code>Application</code> class. The combination of <code>job_seeker_id</code> and <code>job_id</code> should be unique (a seeker can’t apply to the same job more than once), so we can enforce a unique constraint on that pair. We’ll add indexes on <code>job_seeker_id</code> and <code>job_id</code> to quickly find all applications by a seeker or for a job. The <code>status</code> field will also be indexed to allow employers to filter applications by status (e.g., show all 'interview' status applications for a job).</p>
<p><strong>6. Message Table:</strong> This table stores the messages exchanged between users through the system’s messaging feature. It enables one-to-many relationships for both senders and receivers (each user can send many messages and receive many messages). Attributes:
        - <code>message_id</code> (Primary Key): Unique ID for the message.
        - <code>sender_id</code> (Foreign Key to User): The user who sent the message.
        - <code>receiver_id</code> (Foreign Key to User): The user who is the recipient.
        - <code>content</code>: The text content of the message.
        - <code>timestamp</code>: Date and time when the message was sent.
        - <code>is_read</code>: Boolean indicating whether the receiver has read the message (to show unread messages count, etc.).
        - <code>job_id</code> (Foreign Key to JobListing, optional): A reference to the job listing this message is related to (if applicable). For example, if an employer messages a candidate about a specific job, we can link the message to that job. This can help in organizing messages by job and also ensures that employers can only message candidates who applied to their jobs (by checking the job relationship).
        
        This corresponds to the <code>Message</code> class. Indexes will be placed on <code>sender_id</code>, <code>receiver_id</code>, and <code>timestamp</code> to efficiently retrieve a user’s messages in chronological order. If <code>job_id</code> is used, an index on that will help in filtering messages by job (for employer’s view of candidate messages per job). We might also include a <code>subject</code> field for messages (though many messaging systems just have content; a subject could be the first line or a separate field for clarity).</p>
<p><strong>7. (Optional) Skill Table and JobSeeker_Skill Junction Table:</strong> If we decide to normalize the skills data for better querying, we could have a <code>Skill</code> table that lists all unique skills (each skill has an ID and name, e.g., 'Java', 'Project Management', etc.), and then a many-to-many junction table <code>JobSeeker_Skill</code> with <code>job_seeker_id</code> and <code>skill_id</code> as foreign keys. This would allow us to quickly find all job seekers with a certain skill by querying the junction table. Similarly, we could have a <code>JobSkill</code> junction table linking JobListing to Skill to indicate required skills for a job. This would enhance search and matching capabilities. For simplicity in this documentation, we described storing skills as a list in the JobSeeker table, but in practice, a normalized approach might be used for better database design. However, given the scope, the simpler approach might suffice initially.</p>
<p><strong>8. (Optional) Application_Status Lookup Table:</strong> Instead of using a free-form string for <code>status</code> in the Application table, we could have an <code>ApplicationStatus</code> table with allowed status values (e.g., 1: 'Applied', 2: 'Reviewed', 3: 'Interview', etc.) and have the Application table store a foreign key to this table. This centralizes the definition of statuses and ensures consistency. It’s a minor design choice; an ENUM type in the database can serve a similar purpose.</p>
<p>Each of these tables will have appropriate constraints and indexes. For example, foreign key constraints will ensure referential integrity (e.g., an application cannot exist for a non-existent job or user). We will also consider data types and lengths: using VARCHAR for strings with appropriate lengths, TEXT for longer fields like descriptions, DATETIME or TIMESTAMP for dates, etc. We might also include <code>created_at</code> and <code>updated_at</code> timestamps in some tables for auditing purposes (e.g., when a message was created, when an application status was last updated).</p>
<p>To visualize the data model, one can imagine an <strong>Entity-Relationship (ER) diagram</strong> where entities are the tables above, and relationships are shown via foreign keys: User has one JobSeeker or one Employer; Employer posts many JobListings; JobSeeker submits many Applications to many JobListings; User sends many Messages and receives many Messages. This aligns with our class diagram relationships (e.g., the one-to-many from Employer to JobListing, the many-to-many between JobSeeker and JobListing via Application, etc.).</p>
<p>By defining this persistent data model, we ensure that all required information from the requirements is captured in the database. For instance, we can store a job seeker’s entire resume and profile, an employer can store multiple job openings, and we can track each application and message. This model also supports the queries we anticipate: finding jobs by criteria, finding candidates by skills, retrieving all applications for a job, getting a user’s messages, etc., will all be possible with efficient database queries given the right indexes and table structures.</p>
<p>In implementing the database, we will write SQL DDL (Data Definition Language) scripts to create these tables with the specified columns and constraints. We might also set up initial data, such as default admin user or some sample jobs, for testing. Once the database is set up according to this model, the application layer can use an ORM or direct SQL to interact with it, ensuring that the data persists between application restarts and is available to all users consistently.</p>
<p>In summary, the persistent data model is the backbone of the Online Job Portal System’s data management. It translates the conceptual entities and relationships from the analysis into a concrete database schema. This schema is designed to be <strong>normalized</strong> (to reduce redundancy and dependency issues) yet practical for the queries we need to perform. With this data model, we can confidently proceed to implement the database and ensure that the system can store and retrieve all necessary information to fulfill the functional requirements of the job portal.</p>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // Chart 2: Employer Recruitment Challenges
            var chart2 = echarts.init(document.getElementById('chart2'));
            var option2 = {
                title: {
                    text: 'Top Challenges for Employers on Job Boards (2024)',
                    left: 'center',
                    textStyle: { fontSize: 18, fontWeight: 'bold' }
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' }
                },
                grid: {
                    left: '3%',
                    right: '4%',
                    bottom: '3%',
                    containLabel: true
                },
                xAxis: {
                    type: 'value',
                    name: 'Percentage of Employers (%)',
                    nameLocation: 'middle',
                    nameGap: 30,
                    axisLabel: { formatter: '{value}%' }
                },
                yAxis: {
                    type: 'category',
                    data: ['Cost of using job board', 'Ghosting by applicants', 'Too many unqualified applicants'],
                    axisLabel: { fontSize: 14 }
                },
                series: [{
                    name: 'Challenge',
                    type: 'bar',
                    data: [44.0, 51.0, 63.3],
                    label: {
                        show: true,
                        position: 'right',
                        formatter: '{c}%',
                        fontSize: 14,
                        fontWeight: 'bold'
                    },
                    itemStyle: {
                        color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                            { offset: 0, color: '#83bff6' },
                            { offset: 0.5, color: '#188df0' },
                            { offset: 1, color: '#188df0' }
                        ])
                    }
                }]
            };
            chart2.setOption(option2);

            // Chart 10: Proposed Three-Tier System Architecture
            var chart10 = echarts.init(document.getElementById('chart10'));
            var option10 = {
                title: {
                    text: 'Proposed Three-Tier System Architecture',
                    left: 'center',
                    textStyle: { fontSize: 18, fontWeight: 'bold' }
                },
                tooltip: {
                    formatter: function (params) {
                        if (params.dataType === 'node') {
                            return params.name.replace(/\\n/g, '<br/>');
                        }
                    }
                },
                series: [{
                    type: 'graph',
                    layout: 'none',
                    symbolSize: 80,
                    roam: false,
                    label: {
                        show: true,
                        fontSize: 12,
                        color: '#fff',
                        formatter: function(params) {
                            return params.name.replace(/\\n/g, '\n');
                        }
                    },
                    edgeSymbol: ['circle', 'arrow'],
                    edgeSymbolSize: [4, 10],
                    data: [
                        { name: 'Client Tier\n(Web Browser)', x: 400, y: 50, symbolSize: 100, itemStyle: { color: '#3498db' } },
                        { name: 'Web Tier\n(React/Angular)', x: 400, y: 200, symbolSize: 120, itemStyle: { color: '#2ecc71' } },
                        { name: 'Application Tier\n(Node.js / Django)', x: 400, y: 350, symbolSize: 120, itemStyle: { color: '#f1c40f' } },
                        { name: 'Data Tier\n(PostgreSQL)', x: 400, y: 500, symbolSize: 100, itemStyle: { color: '#e67e22' } }
                    ],
                    links: [
                        { source: 'Client Tier\n(Web Browser)', target: 'Web Tier\n(React/Angular)', label: { show: true, formatter: 'HTTP/HTTPS' } },
                        { source: 'Web Tier\n(React/Angular)', target: 'Application Tier\n(Node.js / Django)', label: { show: true, formatter: 'REST API' } },
                        { source: 'Application Tier\n(Node.js / Django)', target: 'Data Tier\n(PostgreSQL)', label: { show: true, formatter: 'SQL Queries' } }
                    ],
                    lineStyle: {
                        opacity: 0.9,
                        width: 2,
                        curveness: 0
                    }
                }]
            };
            chart10.setOption(option10);

            window.addEventListener('resize', function () {
                chart2.resize();
                chart10.resize();
            });
        });
    </script>
</body>
</html>